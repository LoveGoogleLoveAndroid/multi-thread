### 线程的生命周期
#### 创建：通过new创建一个线程
#### 就绪：通过调用start方法使得线程进入等待队列
#### 运行：等待队列中的线程如果获得了CPU资源，就开始运行
#### 阻塞：线程在运行中调用sleep、join、wait等方法进入阻塞状态，阻塞解除后重新进入到就绪状态
#### 终止：线程运行正常结束，就进入终止状态

### 线程的五种状态
#### NEW：对应创建
#### RUNNABLE：对应就绪和运行
#### TERMINATED：对应终止
#### BLOCKED：对应阻塞，等待锁
#### WAITING：对应阻塞，无限等待另一个线程执行某个动作
#### TIMED_WAITING：对应阻塞，有时间限制的等待另一个线程执行某个动作

### Java中有两类线程
#### 用户线程：运行在前台，执行具体任务，比如程序的主线程，连接网络的子线程等等
#### 守护线程：运行在后台，为其他前台线程服务，一旦所有用户线程都结束运行，守护线程会随着JVM一起结束工作，比如数据库连接池中的监测线程，JVM虚拟机启动后的监测线程，垃圾回收线程
* 通过setDaemon(true)设置在start()方法之前可以将一般线程设置为守护线程
* 在守护线程中产生的线程也是守护线程
* 不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑

### 通过JSTACK查看线程快照
命令：jstack -l 7926

### 线程的可见性
要实现共享变量的可见性，必须保证两点：
* 线程修改后的共享变量能够及时从工作内存刷新到主内存
* 其他线程能够及时把共享变量最新值从主内存更新到自己的工作内存
Java语言层面支持的可见性实现方式有`synchronized`和`volatile`

#### 线程不可见的原因
1. 线程的交叉执行
2. 重排序结合线程交叉执行
3. 共享变量最新值未及时在工作内存和主内存更新

#### synchronized实现可见性
synchronized的原子性可以避免线程的交叉执行，只有一个线程访问临界区，所以重排序在单线程下也不会对结果有影响，而其本身语义可以保证共享变量可以及时更新，
不仅可以实现原子性同步（互斥锁），还能实现可见性，因为JMM关于synchronized有两条规定：
* 线程解锁前，必须把共享变量的最新值刷新到主内存中
* 线程加锁时，将清空工作内存的共享变量的值，从而使用共享变量时需要从主内存重新读取（加锁和解锁需要的时同一把锁）
线程解锁前对共享变量的修改在下次加锁时对其他线程可见，执行互斥锁的过程：
1. 获得互斥锁
2. 清空工作内存
3. 从主内存拷贝变量的最新副本到工作内存
4. 执行代码
5. 将更改后的共享变量的值刷新到主内存
6. 释放互斥锁

#### volatile实现可见性
能够保证可见性，但是不能保证符合操作的原子性，是通过加入内存屏障和禁止重排序优化来实现
* 对volatile变量执行写操作，会在写操作后加入一条store屏障指令，强制刷新主内存
* 对volatile变量执行读操作，会在读操作前加入一条load屏障指令，使得缓存失效
volatile变量每次被线程读取时，都强迫从主内存重读，当该变量发生变化时，又强迫线程将最新值刷新到主内存，这样在任何时刻，不同的线程总能看到该变量的最新值
volatile不能保证原子性，比如number++的表达式是三个步骤，这三个步骤可能被三个线程处理：
1. 读取number的值
2. 将number加1
3. 写入最新的number的值

#### 保证number自增操作原子性的方法
1. 使用synchronized关键字
2. 使用ReentrantLock
3. 使用AtomicInteger


#### as-if-serial
无论如何重排序，程序执行的结果与代码顺序执行的结果一致（Java编译器，运行时和处理器都会保证Java在单线程下遵循as-if-serial语义）




